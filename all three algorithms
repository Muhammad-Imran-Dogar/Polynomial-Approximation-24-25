class AdaptiveApproximation:
    """Base class for adaptive approximation algorithms."""
    def __init__(self, f, p=2, degree=0):
        self.f = f
        self.tree = Tree()
        self.p = p
        self.degree = degree
        self.iterations = 0
        self.states = [self.tree.leaves.copy()]
        self.errors = [self.compute_total_error()]
        self.num_triangles = [len(self.tree.leaves)]
    def save_state(self):
        self.states.append(self.tree.leaves.copy())
        print(f"Frame {len(self.states)-1}: {len(self.tree.leaves)} leaves")  # Add logging
        self.errors.append(self.compute_total_error())
        self.num_triangles.append(len(self.tree.leaves))

    def compute_total_error(self):
        """Compute total L^p error over all leaves."""
        return (sum(compute_local_error(self.f, leaf, self.p, self.degree) ** self.p for leaf in self.tree.leaves)) ** (1 / self.p)

    def save_state(self):
        """Save current triangulation state, error, and triangle count."""
        self.states.append(self.tree.leaves.copy())
        self.errors.append(self.compute_total_error())
        self.num_triangles.append(len(self.tree.leaves))

class FirstAlgorithm(AdaptiveApproximation):
    """First Algorithm (ยง4): Refine based on modified error threshold."""
    def run(self, max_steps=5, threshold=0.1, min_angle=20):
        for _ in range(max_steps):
            self.iterations += 1
            new_leaves = []
            for leaf in self.tree.leaves[:]:
                e = compute_local_error(self.f, leaf, self.p, self.degree)
                children = newest_vertex_bisection(leaf, min_angle)
                children_e = [compute_local_error(self.f, child, self.p, self.degree) for child in children]
                e_tilde = compute_modified_error(leaf, e, children_e)
                if e_tilde > threshold:
                    leaf.add_children(children)
                    new_leaves.extend(children)
            self.tree.update_leaves()
            self.save_state()
            if not new_leaves:
                break

class SecondAlgorithm(AdaptiveApproximation):
    """Second Algorithm (ยง5): Greedy refinement of max-error triangle."""
    def run(self, max_steps=5, tolerance=0.01, min_angle=20):
        for _ in range(max_steps):
            self.iterations += 1
            errors = [(leaf, compute_local_error(self.f, leaf, self.p, self.degree)) for leaf in self.tree.leaves]
            if not errors or max(e for _, e in errors) < tolerance:
                break
            max_leaf, _ = max(errors, key=lambda x: x[1])
            children = newest_vertex_bisection(max_leaf, min_angle)
            max_leaf.add_children(children)
            self.tree.update_leaves()
            self.save_state()

class ModifiedSecondAlgorithm(AdaptiveApproximation):
    """Modified Second Algorithm (ยง7): Continuous with newest vertex bisection."""
    def run(self, tolerance=0.1, max_triangles=100, min_angle=20):
        while self.compute_total_error() > tolerance and len(self.tree.leaves) < max_triangles:
            self.iterations += 1
            errors = [(leaf, compute_local_error(self.f, leaf, self.p, 1)) for leaf in self.tree.leaves]
            max_leaf, _ = max(errors, key=lambda x: x[1])
            children = newest_vertex_bisection(max_leaf, min_angle)
            max_leaf.add_children(children)
            complete_triangulation(self.tree, max_leaf, min_angle)
            self.tree.update_leaves()
            self.save_state()
    def refine(self):
        max_error_leaf = max(self.tree.leaves, key=lambda node: self.compute_modified_error(node))
        children = newest_vertex_bisection(max_error_leaf)
        max_error_leaf.add_children(children)
        self.tree.update_leaves()
        complete_triangulation(self.tree, max_error_leaf)  # Completion step
        self.save_state()  # Ensure this follows completion

